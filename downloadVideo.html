<!DOCTYPE html>
<html lang="en">

<head>
    <title>Download video stream</title>
</head>

<body>
    <script src="https://cdn.jsdelivr.net/npm/underscore@1.13.1/underscore-umd-min.js"></script>
    <script src="https://unpkg.com/file-saver@2.0.5/dist/FileSaver.min.js"></script>
    <script id="script_ffmpeg"></script>
    <script src="https://mehmetemineker.github.io/vanilla-toast/lib/vanilla-toast.min.js"></script>
    <h1>Download video stream</h1>
    <h3>Basic instructions</h3>
    <p>
        In chrome dev tools network tab use this as filter:
    <pre>/dm_video.*m3u8\?tag=1/</pre>
    and then and then play the video. An m3u8 file will be shown. Copy the link address and paste it below to process
    and download the video.
    </p>
    <p>
        All the download buttons are independent alternatives. You only need one. They play better in VLC media player
        and you can use it to convert the video to other formats.
    </p>
    <h3>Controls</h3>
    <div id="controls">
        <div id="input">
            <label>m3u8 video URL</label>
            <input id="url" type="text"
                value=""
                placeholder="https://...etc...m3u8" />
            <button id="button">Process input</button>
        </div>
        <div id="download">
            <button id="buttonvideo_mp4_download" disabled>Recode video as mp4</button>
            <button id="buttonm3u8_internet" disabled>Download internet m3u8 playlist</button>
            <button id="buttonm3u8_local" disabled>Download local m3u8 playlist and ts files</button>
            <button id="buttonvideo_single_ts" disabled>Download single ts file</button>
        </div>
    </div>
    <h3>Getting a normal video file</h3>
    <p>Recoded mp4 file should be a normal mp4 video file generated with ffmpeg but it's generation may fail due to a number of things.</p>
    <p>Internet m3u8 file is a playlist referencing the video fragments online. With it you don't really have the video.
    </p>
    <p>Local m3u8 file is a local playlist and it is downloaded along with the fragments so you really have them.</p>
    <p>Single ts file is just the fragments sticked together with no processing beyond that.
        The video has small cuts due to extra packets (like headers) not removed when joining the fragments. You can use
        ffmpeg or VLC to change format without altering the stream.
    <pre>ffmpeg -i video.ts -vcodec copy -acodec copy -bsf:a aac_adtstoasc video_out.mp4</pre>
    </p>
</body>
<script>

    // Constants
    const default_url = "";
    const ffmpeg_url = "http://bgrins.github.io/videoconverter.js/build/ffmpeg-all-codecs.js";

    // Elements
    var urlElement = document.getElementById("url");
    var button = document.getElementById("button");
    var buttonm3u8_internet = document.getElementById("buttonm3u8_internet");
    var buttonm3u8_local = document.getElementById("buttonm3u8_local");
    var buttonvideo_single_ts = document.getElementById("buttonvideo_single_ts");
    var buttonvideo_mp4_download = document.getElementById("buttonvideo_mp4_download");
    var script_ffmpeg = document.getElementById("script_ffmpeg");

    function httpGetAsync(theUrl, callback, blob = false) {
        var xmlHttp = new XMLHttpRequest();
        xmlHttp.onreadystatechange = function () {
            if (xmlHttp.readyState == 4 && xmlHttp.status == 200) {
                if (blob) {
                    callback(xmlHttp.response);
                } else {
                    callback(xmlHttp.responseText);
                }
            }
        }
        xmlHttp.open("GET", theUrl, true);
        if (blob) {
            xmlHttp.responseType = "blob";
        }
        xmlHttp.send(null);
    }

    function getM3U8Async(url, callback) {
        console.log(url);
        httpGetAsync(url, (content) => {
            var list = content.split(/\r?\n/g);
            var meta = [];
            var best = { pix: -1 };
            _.each(list, (v, i) => {
                if (/^\s*$/.test(v)) {
                } else if (/^(#EXTINF|#EXT-X-STREAM-INF).*/.test(v)) {
                    // console.log("extinf", v);
                    meta.push(v);
                } else if (/^#.*/.test(v)) {
                    // console.log("dunno", v);
                } else {
                    // URL
                    try {
                        console.log("url", v, meta);
                        var bw = _.find(_.map(meta, (x) => {
                            var m = /\WBANDWIDTH=(\d+)/.exec(x);
                            return m ? m[1] - 0 : null;
                        })) || 0;
                        var res = _.find(_.map(meta, (x) => {
                            var m = /\WRESOLUTION=([^,]+)/.exec(x);
                            return m ? m[1] : null;
                        })) || null;
                        var pix = 1;
                        if (res) {
                            var res2 = _.map(res.split(/[xX]/), (z) => z - 0);
                            pix = res2[0] * res2[1];
                        }
                        if (pix > best.pix) {
                            best = { url: v, bw: bw, res: res, pix: pix };
                        }
                    } finally {
                        meta = [];
                    }

                }
            });
            console.log("best", best);
            var url2 = new URL(best.url, url).href;
            console.log("best url", url2);
            httpGetAsync(url2, callback);
        });
    }

    function generateSingleTs(callback) {
        var data = [];
        var urls = _.map(window.__tsFiles, f => f.url);
        var extension = (_.find(window.__tsFiles)?.fileName?.match(/([.][^.]+)$/) || ['', '.mpg'])[1];
        function r() {
            if (urls.length == 0) {
                var b = new Blob(data, { type: 'application/octet-binary' });
                console.log("All data downloaded", data.length, b.size);
                callback({ blob: b, extension: extension, parts: data.length });
            } else {
                httpGetAsync(urls.shift(), c => {
                    console.log(".");
                    data.push(c);
                    r();
                }, blob = true);
            }
        }
        r();
    }

    function readyToDownload(internet, local, tsFiles) {
        window.__m3u8_internet = internet;
        window.__m3u8_local = local;
        window.__tsFiles = tsFiles;
        buttonm3u8_internet.disabled = false;
        buttonm3u8_local.disabled = false;
        buttonvideo_single_ts.disabled = false;
        buttonvideo_mp4_download.disabled = false;
    }

    function disableDownload(internet, local, tsFiles) {
        buttonm3u8_internet.disabled = true;
        buttonm3u8_local.disabled = true;
        buttonvideo_single_ts.disabled = true;
        buttonvideo_mp4_download.disabled = true;
    }

    function enable_ffmpeg(callback) {
        var enabled = window.ffmpeg_run || false;
        if (enabled) {
            callback();
        } else {
            vt.warn("Loading ffmpeg...");
            var listener;
            listener = (e) => {
                vt.success("ffmpeg successfully loaded!!!");
                script_ffmpeg.removeEventListener('load', listener);
                callback();
            };
            script_ffmpeg.addEventListener('load', listener);
            script_ffmpeg.src = ffmpeg_url;
        }
    }

    // Events
    button.addEventListener('click', (button) => {
        var url = urlElement.value;
        getM3U8Async(url, content => {
            console.log("m3u8 content", content);
            var list = content.split(/\r?\n/g);
            var content2 = "";
            var content3 = "";
            var tsFiles = [];
            _.each(list, (v, i) => {
                if (/^\s*$/.test(v)) {
                    if (i < list.length - 1) { // IDK
                        content2 += v + "\r\n";
                        content3 += v + "\r\n";
                    }
                } else if (/^#.*/.test(v)) { // Comment/Extension
                    content2 += v + "\r\n";
                    content3 += v + "\r\n";
                } else {
                    // URL
                    var url2 = new URL(v, url).href;
                    var fileName = _.last(new URL(v, url).pathname.split("/"));
                    // console.log("url", v, url2);
                    content2 += url2 + "\r\n";
                    content3 += fileName + "\r\n";
                    tsFiles.push({ fileName: fileName, url: url2 });
                }
            });
            readyToDownload(content2, content3, tsFiles);
        });
    });

    buttonm3u8_internet.addEventListener('click', (x) => {
        var blob = new Blob([window.__m3u8_internet], { type: "text/plain;charset=utf-8" });
        window.saveAs(blob, "playlist_internet.m3u8");
    });

    buttonm3u8_local.addEventListener('click', (x) => {
        _.each(window.__tsFiles, f => {
            window.saveAs(f.url, f.fileName);
        });
        var blob0 = new Blob([window.__m3u8_local], { type: "text/plain;charset=utf-8" });
        window.saveAs(blob0, "playlist_local.m3u8");
    });

    buttonvideo_single_ts.addEventListener('click', (x) => {
        var callback = (res) => window.saveAs(res.blob, "video" + res.extension);
        generateSingleTs(callback);
    });

    urlElement.addEventListener('focus', (x) => {
        urlElement.select();
        disableDownload();
    });

    buttonvideo_mp4_download.addEventListener('click', (x) => {
        enable_ffmpeg(() => {
            var callback = (res) => {
                var fileName = "video" + x.extension;
                res.blob.arrayBuffer().then(buffer => {
                    var array = new Uint8Array(buffer);
                    var ffmpeg_result = ffmpeg_run({
                        arguments: ['-nostdin', '-i', fileName, '-vcodec', 'copy', '-strict', '-2', 'video_out.mp4'],
                        files: [
                            {
                                data: array,
                                name: fileName
                            }
                        ]
                    });
                    var file = _.find(ffmpeg_result);
                    console.log(file);
                    if (file && file.data.byteLength > 0) {
                        vt.success(file.name + " successfully generated!!!");
                        window.saveAs(new Blob([file.data]), file.name);
                    } else {
                        vt.error("Video conversion failed");
                    }
                });
            };
            vt.warn("Running ffmpeg...");
            generateSingleTs(callback);
        });
    });
    if (default_url) {
        urlElement.value = default_url;
        button.click();
    }
</script>

</html>
